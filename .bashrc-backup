# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# NOTA: HISTCONTROL optimizado movido a sección de rendimiento (línea ~480)
# HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
# NOTA: Configuración de historia optimizada movida a sección de rendimiento (línea ~480)
# HISTSIZE=1000
# HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

# Función para generar el prompt con información de Git mejorada
# Configuración del prompt personalizado
setup_custom_prompt() {
    local git_info=""
    local git_branch=""
    local venv_info=""
    
    # Verificar si el terminal soporta colores
    local use_colors=false
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        use_colors=true
    fi
    
    # Definir colores usando códigos ANSI simples
    local COLOR_RESET="\033[0m"
    local COLOR_PATH="\033[1;36m"             # Cyan brillante para la ruta
    local COLOR_BRANCH="\033[1;32m"           # Verde brillante para branch
    local COLOR_AHEAD="\033[1;35m"            # Magenta para ahead (push pendiente)
    local COLOR_BEHIND="\033[1;33m"           # Amarillo para behind (pull pendiente)
    local COLOR_STAGED="\033[1;92m"           # Verde claro para staged
    local COLOR_UNSTAGED="\033[1;91m"         # Rojo claro para unstaged
    local COLOR_UNTRACKED="\033[1;93m"        # Amarillo claro para untracked
    local COLOR_PROMPT="\033[1;37m"           # Blanco brillante para el símbolo $
    local COLOR_VENV="\033[92m"               # Verde claro para virtual environment
    
    # Detectar entorno virtual de Python
    if [ -n "$VIRTUAL_ENV" ]; then
        local venv_name=$(basename "$VIRTUAL_ENV")
        if [ "$use_colors" = true ]; then
            venv_info="${COLOR_VENV}($venv_name)${COLOR_RESET} "
        else
            venv_info="($venv_name) "
        fi
    fi
    
    # Verificar si estamos en un repositorio Git
    if git rev-parse --git-dir >/dev/null 2>&1; then
        # Obtener branch actual
        git_branch=$(git symbolic-ref --short HEAD 2>/dev/null || \
                    git describe --tags --exact-match 2>/dev/null || \
                    git rev-parse --short HEAD 2>/dev/null)
        
        if [ -n "$git_branch" ]; then
            local status_parts=""
            
            # Verificar si hay cambios por hacer push (ahead) o pull (behind)
            local upstream_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
            if [ -n "$upstream_branch" ]; then
                local ahead_count=$(git rev-list --count HEAD ^"$upstream_branch" 2>/dev/null || echo "0")
                local behind_count=$(git rev-list --count "$upstream_branch" ^HEAD 2>/dev/null || echo "0")
                
                if [ "$ahead_count" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_AHEAD}⇡$ahead_count${COLOR_RESET}"
                    else
                        status_parts="$status_parts⇡$ahead_count"
                    fi
                fi
                if [ "$behind_count" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_BEHIND}⇣$behind_count${COLOR_RESET}"
                    else
                        status_parts="$status_parts⇣$behind_count"
                    fi
                fi
            fi
            
            # Verificar estado del working directory y staging area
            local git_status_output=$(git status --porcelain 2>/dev/null)
            
            if [ -n "$git_status_output" ]; then
                # Contar archivos staged (en el índice, listos para commit)
                local staged_files=$(echo "$git_status_output" | grep -E '^[MADRC]' | wc -l)
                if [ "$staged_files" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_STAGED}●$staged_files${COLOR_RESET}"
                    else
                        status_parts="$status_parts●$staged_files"
                    fi
                fi
                
                # Contar archivos modificados en working directory (no en staging)
                local modified_files=$(echo "$git_status_output" | grep -E '^.[MADRC]' | wc -l)
                if [ "$modified_files" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_UNSTAGED}✚$modified_files${COLOR_RESET}"
                    else
                        status_parts="$status_parts✚$modified_files"
                    fi
                fi
                
                # Contar archivos no rastreados
                local untracked_files=$(echo "$git_status_output" | grep -E '^\?\?' | wc -l)
                if [ "$untracked_files" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_UNTRACKED}…$untracked_files${COLOR_RESET}"
                    else
                        status_parts="$status_parts…$untracked_files"
                    fi
                fi
            fi
            
            # Construir información de Git
            if [ "$use_colors" = true ]; then
                git_info=" ${COLOR_BRANCH}($git_branch)${COLOR_RESET}"
                
                # Añadir símbolos de estado si existen
                if [ -n "$status_parts" ]; then
                    git_info="$git_info [$status_parts]"
                fi
            else
                git_info=" ($git_branch)"
                if [ -n "$status_parts" ]; then
                    git_info="$git_info[$status_parts]"
                fi
            fi
        fi
    fi
    
    # Construir el prompt completo (venv + ruta + git info)
    if [ "$use_colors" = true ]; then
        PS1="$venv_info\[${COLOR_PATH}\]\w\[${COLOR_RESET}\]$git_info\[${COLOR_PROMPT}\] \$ \[${COLOR_RESET}\]"
    else
        PS1="$venv_info\w$git_info \$ "
    fi
}

# Función para auto-activar entornos virtuales de Python
auto_activate_venv() {
    # Si ya hay un entorno virtual activo, verificar si sigue siendo el correcto
    if [ -n "$VIRTUAL_ENV" ]; then
        local current_venv_dir=$(dirname "$VIRTUAL_ENV")
        # Si no estamos en el directorio del entorno virtual actual, desactivarlo
        if [[ ! "$PWD" == "$current_venv_dir"* ]]; then
            deactivate 2>/dev/null || true
        fi
    fi
    
    # Buscar entorno virtual en el directorio actual y sus padres
    local dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/.venv/bin/activate" ]; then
            # Solo activar si no hay ya un entorno virtual activo o es diferente
            if [ -z "$VIRTUAL_ENV" ] || [ "$VIRTUAL_ENV" != "$dir/.venv" ]; then
                source "$dir/.venv/bin/activate"
            fi
            return
        elif [ -f "$dir/venv/bin/activate" ]; then
            # También buscar 'venv' (nombre común alternativo)
            if [ -z "$VIRTUAL_ENV" ] || [ "$VIRTUAL_ENV" != "$dir/venv" ]; then
                source "$dir/venv/bin/activate"
            fi
            return
        fi
        dir=$(dirname "$dir")
    done
}

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases (configurados más abajo en sección optimizada)

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi
# eval "$(gh copilot alias -- bash)"

# ======================================
# DOCKER ALIASES PARA DESARROLLO FULLSTACK
# ======================================

# Docker básico
alias d='docker'
alias dc='docker compose'
alias dps='docker ps'
alias dpsa='docker ps -a'
alias di='docker images'
alias dv='docker volume ls'
alias dn='docker network ls'

# Docker compose shortcuts
alias dcup='docker compose up'
alias dcupd='docker compose up -d'  # detached mode
alias dcdown='docker compose down'
alias dcbuild='docker compose build'
alias dcrestart='docker compose restart'
alias dclogs='docker compose logs -f'  # follow logs
alias dcps='docker compose ps'

# Node.js con Docker
alias node='docker run --rm -it -v "$PWD":/app -w /app node:20-alpine node'
alias npm='docker run --rm -it -v "$PWD":/app -w /app -v ~/.npm:/root/.npm node:20-alpine npm'
alias npx='docker run --rm -it -v "$PWD":/app -w /app -v ~/.npm:/root/.npm node:20-alpine npx'
alias yarn='docker run --rm -it -v "$PWD":/app -w /app -v ~/.yarn:/root/.yarn node:20-alpine yarn'

# Python con Docker
alias python='docker run --rm -it -v "$PWD":/app -w /app python:3.11-alpine python'
alias pip='docker run --rm -it -v "$PWD":/app -w /app -v ~/.cache/pip:/root/.cache/pip python:3.11-alpine pip'

# PHP con Docker
alias php='docker run --rm -it -v "$PWD":/app -w /app php:8.2-cli php'
alias composer='docker run --rm -it -v "$PWD":/app -w /app -v ~/.composer:/root/.composer composer:latest'

# Base de datos con Docker
alias mysql-client='docker run --rm -it --network host mysql:8.0 mysql'
alias psql='docker run --rm -it --network host postgres:15 psql'

# Utilidades de desarrollo
alias dexec='docker exec -it'  # Para entrar a un contenedor corriendo
alias dshell='docker run --rm -it -v "$PWD":/app -w /app --entrypoint /bin/sh'  # Shell temporal
alias dclean='docker system prune -f && docker volume prune -f'  # Limpiar Docker
alias dcleanall='docker system prune -a -f --volumes'  # Limpieza completa (¡cuidado!)

# Git con formato mejorado (funciona con tu prompt actual)
# NOTA: Aliases de Git optimizados movidos a sección principal (línea ~280)
# alias gst='git status'
# alias glog='git log --oneline --graph --decorate --all'
# alias gco='git checkout'
# etc...

# =============================================================================
# 📋 ALIASES ÚTILES Y OPTIMIZADOS
# =============================================================================

# Navegación básica (aliases principales)
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias mkdir='mkdir -p'
alias h='history'
alias c='clear'

# Git shortcuts (optimizados)
alias gs='git status'
alias gst='git status'
alias ga='git add'
alias gc='git commit'
alias gcm='git commit -m'
alias gca='git commit -a'
alias gp='git push'
alias gpl='git pull'
alias gl='git log --oneline'
alias glog='git log --oneline --graph --decorate --all'
alias gco='git checkout'
alias gcb='git checkout -b'

# Desarrollo Python (unificado)
alias py='python3'
alias serve='python3 -m http.server'

# MCP shortcuts específicos
alias mcp='cd $HOME/mcp-servers'
alias mcptest='mcpask "test de conexión"'

# NOTA: auto_activate_venv ya está definida en línea 169
# Función combinada que maneja auto-activación de venv y prompt personalizado
update_prompt_and_venv() {
    auto_activate_venv
    # Aplicar el prompt personalizado
    setup_custom_prompt
}

# Configurar PROMPT_COMMAND para auto-activación de venv y prompt personalizado
PROMPT_COMMAND=update_prompt_and_venv

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    # Configuración del título de la terminal
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases

# ======================================
# GITHUB COPILOT CLI ALIASES
# ======================================

# Aliases para GitHub Copilot CLI
alias ask='gh copilot suggest'
alias explain='gh copilot explain'
alias cpl='gh copilot'  # Acceso directo completo

# =============================================================================
# 🚀 MCP SERVERS - CONFIGURACIÓN OPTIMIZADA (Groq-based)
# =============================================================================

# PATH para comandos MCP actuales
export PATH="$PATH:$HOME/mcp-servers"
export MCP_PATH="$HOME/mcp-servers"

# =============================================================================
# 🔧 HERRAMIENTAS DE DESARROLLO
# =============================================================================

# Python local (instalado)
export PATH="$HOME/.local/bin:$PATH"

# GitHub CLI completion (instalado)
eval "$(gh completion -s bash)"

# Para habilitar otras herramientas cuando las instales puedes agregarlas aquí

# =============================================================================
# 🤖 FUNCIONES DE AYUDA MCP
# =============================================================================

# Función de ayuda para comandos MCP
mcp_help() {
    echo "🚀 MCP Servers - Comandos disponibles:"
    echo ""
    echo "📱 COMANDOS PRINCIPALES:"
    echo "  mcpask   - Preguntas rápidas"
    echo "  mcpcode  - Asistente de código"
    echo "  mcpai    - Agente completo"
    echo "  mcpgroq  - Chat directo"
    echo ""
    echo "⚙️ UTILIDADES:"
    echo "  mcp      - Ir al directorio MCP"
    echo "  mcptest  - Test rápido de conexión"
    echo ""
    echo "💡 EJEMPLOS:"
    echo "  mcpask 'qué es Docker'"
    echo "  mcpcode 'crear API con FastAPI'"
    echo "  mcpai chat 'analiza mi proyecto'"
}

# Función para análisis rápido de archivos
analyze_file() {
    if [ -f "$1" ]; then
        echo "🔍 Analizando archivo: $1"
        mcpcode "Analiza este código: $(cat "$1")"
    else
        echo "❌ Archivo no encontrado: $1"
        echo "Uso: analyze_file <archivo>"
    fi
}

# =============================================================================
# 🎯 OPTIMIZACIONES DE RENDIMIENTO
# =============================================================================

# Historia mejorada
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoreboth:erasedups
shopt -s histappend
