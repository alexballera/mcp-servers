# Archivo de ejemplo para configuración de entorno MCP
# Copia este archivo como .bashrc en tu directorio home y ajusta las variables
# según tu configuración específica.
#
# Variables que debes personalizar:
# - MCP_HOME: Ruta donde clonaste el repositorio
# - GITHUB_TOKEN: Tu token personal de GitHub (si usas integración)
# - Otras rutas específicas de tu sistema
#

# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

# Función para generar el prompt con información de Git mejorada
set_bash_prompt() {
    local git_info=""
    local git_branch=""
    local venv_info=""
    
    # Verificar si el terminal soporta colores
    local use_colors=false
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        use_colors=true
    fi
    
    # Definir colores usando códigos ANSI simples
    local COLOR_RESET="\033[0m"
    local COLOR_PATH="\033[1;36m"             # Cyan brillante para la ruta
    local COLOR_BRANCH="\033[1;32m"           # Verde brillante para branch
    local COLOR_AHEAD="\033[1;35m"            # Magenta para ahead (push pendiente)
    local COLOR_BEHIND="\033[1;33m"           # Amarillo para behind (pull pendiente)
    local COLOR_STAGED="\033[1;92m"           # Verde claro para staged
    local COLOR_UNSTAGED="\033[1;91m"         # Rojo claro para unstaged
    local COLOR_UNTRACKED="\033[1;93m"        # Amarillo claro para untracked
    local COLOR_PROMPT="\033[1;37m"           # Blanco brillante para el símbolo $
    local COLOR_VENV="\033[92m"               # Verde claro para virtual environment
    
    # Detectar entorno virtual de Python
    if [ -n "$VIRTUAL_ENV" ]; then
        local venv_name=$(basename "$VIRTUAL_ENV")
        if [ "$use_colors" = true ]; then
            venv_info="${COLOR_VENV}($venv_name)${COLOR_RESET} "
        else
            venv_info="($venv_name) "
        fi
    fi
    
    # Verificar si estamos en un repositorio Git
    if git rev-parse --git-dir >/dev/null 2>&1; then
        # Obtener branch actual
        git_branch=$(git symbolic-ref --short HEAD 2>/dev/null || \
                    git describe --tags --exact-match 2>/dev/null || \
                    git rev-parse --short HEAD 2>/dev/null)
        
        if [ -n "$git_branch" ]; then
            local status_parts=""
            
            # Verificar si hay cambios por hacer push (ahead) o pull (behind)
            local upstream_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
            if [ -n "$upstream_branch" ]; then
                local ahead_count=$(git rev-list --count HEAD ^"$upstream_branch" 2>/dev/null || echo "0")
                local behind_count=$(git rev-list --count "$upstream_branch" ^HEAD 2>/dev/null || echo "0")
                
                if [ "$ahead_count" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_AHEAD}⇡$ahead_count${COLOR_RESET}"
                    else
                        status_parts="$status_parts⇡$ahead_count"
                    fi
                fi
                if [ "$behind_count" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_BEHIND}⇣$behind_count${COLOR_RESET}"
                    else
                        status_parts="$status_parts⇣$behind_count"
                    fi
                fi
            fi
            
            # Verificar estado del working directory y staging area
            local git_status_output=$(git status --porcelain 2>/dev/null)
            
            if [ -n "$git_status_output" ]; then
                # Contar archivos staged (en el índice, listos para commit)
                local staged_files=$(echo "$git_status_output" | grep -E '^[MADRC]' | wc -l)
                if [ "$staged_files" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_STAGED}●$staged_files${COLOR_RESET}"
                    else
                        status_parts="$status_parts●$staged_files"
                    fi
                fi
                
                # Contar archivos modificados en working directory (no en staging)
                local modified_files=$(echo "$git_status_output" | grep -E '^.[MADRC]' | wc -l)
                if [ "$modified_files" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_UNSTAGED}✚$modified_files${COLOR_RESET}"
                    else
                        status_parts="$status_parts✚$modified_files"
                    fi
                fi
                
                # Contar archivos no rastreados
                local untracked_files=$(echo "$git_status_output" | grep -E '^\?\?' | wc -l)
                if [ "$untracked_files" -gt 0 ]; then
                    if [ "$use_colors" = true ]; then
                        status_parts="$status_parts${COLOR_UNTRACKED}…$untracked_files${COLOR_RESET}"
                    else
                        status_parts="$status_parts…$untracked_files"
                    fi
                fi
            fi
            
            # Construir información de Git
            if [ "$use_colors" = true ]; then
                git_info=" ${COLOR_BRANCH}($git_branch)${COLOR_RESET}"
                
                # Añadir símbolos de estado si existen
                if [ -n "$status_parts" ]; then
                    git_info="$git_info [$status_parts]"
                fi
            else
                git_info=" ($git_branch)"
                if [ -n "$status_parts" ]; then
                    git_info="$git_info[$status_parts]"
                fi
            fi
        fi
    fi
    
    # Construir el prompt completo (venv + ruta + git info)
    if [ "$use_colors" = true ]; then
        PS1="$venv_info\[${COLOR_PATH}\]\w\[${COLOR_RESET}\]$git_info\[${COLOR_PROMPT}\] \$ \[${COLOR_RESET}\]"
    else
        PS1="$venv_info\w$git_info \$ "
    fi
}

# Configurar PROMPT_COMMAND para actualizar el prompt y manejar entornos virtuales
PROMPT_COMMAND=update_prompt_and_venv

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi
# eval "$(gh copilot alias -- bash)"

# ======================================
# DOCKER ALIASES PARA DESARROLLO FULLSTACK
# ======================================

# Docker básico
alias d='docker'
alias dc='docker compose'
alias dps='docker ps'
alias dpsa='docker ps -a'
alias di='docker images'
alias dv='docker volume ls'
alias dn='docker network ls'

# Docker compose shortcuts
alias dcup='docker compose up'
alias dcupd='docker compose up -d'  # detached mode
alias dcdown='docker compose down'
alias dcbuild='docker compose build'
alias dcrestart='docker compose restart'
alias dclogs='docker compose logs -f'  # follow logs
alias dcps='docker compose ps'

# Node.js con Docker
alias node='docker run --rm -it -v "$PWD":/app -w /app node:20-alpine node'
alias npm='docker run --rm -it -v "$PWD":/app -w /app -v ~/.npm:/root/.npm node:20-alpine npm'
alias npx='docker run --rm -it -v "$PWD":/app -w /app -v ~/.npm:/root/.npm node:20-alpine npx'
alias yarn='docker run --rm -it -v "$PWD":/app -w /app -v ~/.yarn:/root/.yarn node:20-alpine yarn'

# Python con Docker
alias python='docker run --rm -it -v "$PWD":/app -w /app python:3.11-alpine python'
alias pip='docker run --rm -it -v "$PWD":/app -w /app -v ~/.cache/pip:/root/.cache/pip python:3.11-alpine pip'

# PHP con Docker
alias php='docker run --rm -it -v "$PWD":/app -w /app php:8.2-cli php'
alias composer='docker run --rm -it -v "$PWD":/app -w /app -v ~/.composer:/root/.composer composer:latest'

# Base de datos con Docker
alias mysql-client='docker run --rm -it --network host mysql:8.0 mysql'
alias psql='docker run --rm -it --network host postgres:15 psql'

# Utilidades de desarrollo
alias dexec='docker exec -it'  # Para entrar a un contenedor corriendo
alias dshell='docker run --rm -it -v "$PWD":/app -w /app --entrypoint /bin/sh'  # Shell temporal
alias dclean='docker system prune -f && docker volume prune -f'  # Limpiar Docker
alias dcleanall='docker system prune -a -f --volumes'  # Limpieza completa (¡cuidado!)

# Git con formato mejorado (funciona con tu prompt actual)
alias gst='git status'
alias glog='git log --oneline --graph --decorate --all'
alias gco='git checkout'
alias gcb='git checkout -b'
alias gp='git push'
alias gpl='git pull'
alias ga='git add'
alias gc='git commit'
alias gca='git commit -a'
alias gcm='git commit -m'

# Shortcuts generales
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias grep='grep --color=auto'
alias mkdir='mkdir -p'
alias h='history'
alias c='clear'

# Para proyectos con diferentes stacks
# Descomenta según tu stack principal:
# alias dev='docker compose -f docker-compose.dev.yml up -d'  # MEAN/MERN
# alias dev='docker compose -f docker-compose.dev.yml up -d'  # LAMP
# alias dev='docker compose -f docker-compose.dev.yml up -d'  # Django

# Limpiar variables temporales después de configurar el prompt
# unset color_prompt force_color_prompt

# Función para auto-activar entornos virtuales de Python
auto_activate_venv() {
    # Si ya hay un entorno virtual activo, verificar si sigue siendo el correcto
    if [ -n "$VIRTUAL_ENV" ]; then
        local current_venv_dir=$(dirname "$VIRTUAL_ENV")
        # Si no estamos en el directorio del entorno virtual actual, desactivarlo
        if [[ ! "$PWD" == "$current_venv_dir"* ]]; then
            deactivate 2>/dev/null || true
        fi
    fi
    
    # Buscar entorno virtual en el directorio actual y sus padres
    local dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/.venv/bin/activate" ]; then
            # Solo activar si no hay ya un entorno virtual activo o es diferente
            if [ -z "$VIRTUAL_ENV" ] || [ "$VIRTUAL_ENV" != "$dir/.venv" ]; then
                source "$dir/.venv/bin/activate"
            fi
            return
        elif [ -f "$dir/venv/bin/activate" ]; then
            # También buscar 'venv' (nombre común alternativo)
            if [ -z "$VIRTUAL_ENV" ] || [ "$VIRTUAL_ENV" != "$dir/venv" ]; then
                source "$dir/venv/bin/activate"
            fi
            return
        fi
        dir=$(dirname "$dir")
    done
}

# Función combinada que maneja prompt y auto-activación
update_prompt_and_venv() {
    auto_activate_venv
    set_bash_prompt
}

# ======================================
# GITHUB COPILOT CLI ALIASES
# ======================================

# Aliases para GitHub Copilot CLI
alias ask='gh copilot suggest'
alias explain='gh copilot explain'
alias cpl='gh copilot'  # Acceso directo completo

# ======================================
# OLLAMA ALIASES Y FUNCIONES
# ======================================

# Aliases básicos para Ollama
alias ol='ollama'
alias ollist='ollama list'
alias olpull='ollama pull'
alias olrm='ollama rm'
alias olrun='ollama run'
alias olserve='ollama serve'
alias olshow='ollama show'

# Aliases para modelos específicos
alias llama='ollama run llama3'
alias coding-llama='ollama run codellama'

# Función para chat interactivo con Llama 3
chat() {
    if [ -z "$1" ]; then
        echo "Iniciando chat interactivo con Llama 3..."
        ollama run llama3
    else
        echo "Pregunta a Llama 3: $*"
        ollama run llama3 "$*"
    fi
}

# Función para ayuda con código usando Code Llama
coding() {
    if [ -z "$1" ]; then
        echo "Iniciando sesión de programación con Code Llama..."
        ollama run codellama
    else
        echo "Pregunta de programación: $*"
        ollama run codellama "$*"
    fi
}

# Función para revisar código en un archivo
review() {
    if [ -z "$1" ]; then
        echo "Uso: review <archivo>"
        echo "Ejemplo: review script.py"
        return 1
    fi
    
    if [ ! -f "$1" ]; then
        echo "Error: El archivo '$1' no existe."
        return 1
    fi
    
    echo "Revisando código en $1 con Code Llama..."
    cat "$1" | ollama run codellama "Revisa este código y proporciona sugerencias de mejora:"
}

# Función para explicar código en un archivo
explain_code() {
    if [ -z "$1" ]; then
        echo "Uso: explain_code <archivo>"
        echo "Ejemplo: explain_code script.py"
        return 1
    fi
    
    if [ ! -f "$1" ]; then
        echo "Error: El archivo '$1' no existe."
        return 1
    fi
    
    echo "Explicando código en $1..."
    cat "$1" | ollama run codellama "Explica detalladamente qué hace este código:"
}

# Función para optimizar código
optimize() {
    if [ -z "$1" ]; then
        echo "Uso: optimize <archivo>"
        echo "Ejemplo: optimize script.py"
        return 1
    fi
    
    if [ ! -f "$1" ]; then
        echo "Error: El archivo '$1' no existe."
        return 1
    fi
    
    echo "Optimizando código en $1..."
    cat "$1" | ollama run codellama "Optimiza este código y explica las mejoras:"
}

# Función para obtener ayuda rápida sobre comandos
help_cmd() {
    if [ -z "$1" ]; then
        echo "Uso: help_cmd <comando>"
        echo "Ejemplo: help_cmd git push"
        return 1
    fi
    
    ollama run llama3 "Explica brevemente cómo usar el comando: $*"
}

# ======================================
# MCP SERVER ALIASES
# ======================================

# Alias para MCP Server

# Función para manejar el MCP Server desde cualquier directorio
mcp() {
    if [ -z "$1" ]; then
        echo "Uso: mcp <comando>"
        echo "Comandos disponibles:"
        echo "  start  - Iniciar servidor MCP"
        echo "  chat   - Iniciar cliente de chat"
        echo "  help   - Mostrar ayuda"
        echo "  client - Ejecutar cliente directo"
        return 1
    fi
    
    case "$1" in
        start)
            ;;
        chat|client)
            ;;
        help)
            echo "MCP Server - GitHub & Google Docs Integration"
            echo ""
            echo "Comandos disponibles:"
            echo "  mcp start  - Iniciar servidor MCP"
            echo "  mcp chat   - Iniciar cliente de chat"  
            echo "  mcp client - Ejecutar cliente directo"
            echo "  mcp help   - Mostrar esta ayuda"
            ;;
        *)
            echo "Comando no reconocido: $1"
            echo "Usa 'mcp help' para ver comandos disponibles"
            ;;
    esac
}

# ======================================
# MCP CLIENT ALIAS
# ======================================

# Alias para usar el cliente MCP desde cualquier directorio con diferentes opciones

# ======================================

# ======================================

# ======================================
# OLLAMA MCP SERVER - CONFIGURACIÓN ACTUALIZADA
# ======================================

# Función principal MCP (reemplaza configuración antigua)
mcp() {
    case "$1" in
        start|server)
            echo "🚀 Iniciando Ollama MCP Server..."
            cd ~$MCP_HOME && .venv/bin/python3 ollama_mcp_server.py
            ;;
        install|setup)
            echo "📦 Ejecutando instalación/configuración..."
            cd ~$MCP_HOME && python install.py
            ;;
        models)
            echo "🤖 Modelos de Ollama instalados:"
            ollama list
            ;;
        pull)
            if [ -z "$2" ]; then
                echo "Uso: mcp pull <modelo>"
                echo "Ejemplos:"
                echo "  mcp pull deepseek-coder:6.7b"
                echo "  mcp pull qwen2.5-coder:7b"
                echo "  mcp pull llama3.2:3b"
            else
                echo "📥 Instalando modelo: $2"
                ollama pull "$2"
            fi
            ;;
        status)
            echo "📊 Estado del sistema:"
            echo "Ollama: $(ollama list | wc -l) modelos instalados"
            echo "MCP Server: ~$MCP_HOME/"
            echo "Config: $([ -f ~$MCP_HOME/.env ] && echo '✅ Configurado' || echo '❌ Falta .env')"
            ;;
        # Comandos directos de agente (sin servidor interactivo)
        chat)
            shift
            echo "💬 Chat con Ollama..."
            cd ~$MCP_HOME && echo "chat $*" | .venv/bin/python3 -c "
import sys
sys.path.append('.')
from ollama_mcp_server import OllamaMCPServer
import asyncio

async def run_command():
    server = OllamaMCPServer()
    command = input().strip()
    parsed = server.parse_command(command)
    if 'error' not in parsed:
        result = await server.handle_request(parsed)
        if result.get('type') == 'chat':
            print(result['response'])
        else:
            print('Error en la respuesta')
    else:
        print(parsed['error'])

asyncio.run(run_command())
"
            ;;
        code)
            shift
            echo "💻 Asistencia de código..."
            cd ~$MCP_HOME && echo "code $*" | .venv/bin/python3 -c "
import sys
sys.path.append('.')
from ollama_mcp_server import OllamaMCPServer
import asyncio

async def run_command():
    server = OllamaMCPServer()
    command = input().strip()
    parsed = server.parse_command(command)
    if 'error' not in parsed:
        result = await server.handle_request(parsed)
        if result.get('type') == 'code':
            print(result['response'])
        else:
            print('Error en la respuesta')
    else:
        print(parsed['error'])

asyncio.run(run_command())
"
            ;;
        github)
            shift
            echo "📁 Consultando GitHub..."
            cd ~$MCP_HOME && echo "github_search $*" | .venv/bin/python3 -c "
import sys
sys.path.append('.')
from ollama_mcp_server import OllamaMCPServer
import asyncio
import json

async def run_command():
    server = OllamaMCPServer()
    command = input().strip()
    parsed = server.parse_command(command)
    if 'error' not in parsed:
        result = await server.handle_request(parsed)
        if result.get('type') == 'github':
            print(json.dumps(result, indent=2, ensure_ascii=False))
        else:
            print('Error en la respuesta')
    else:
        print(parsed['error'])

asyncio.run(run_command())
"
            ;;
        help|*)
            echo "🤖 Ollama MCP Server - Sistema integrado de IA"
            echo ""
            echo "📊 COMANDOS INTERACTIVOS:"
            echo "  mcp start    - Iniciar servidor MCP interactivo"
            echo ""
            echo "🚀 COMANDOS DIRECTOS (desde cualquier proyecto):"
            echo "  mcp chat <mensaje>     - Chat directo con Ollama"
            echo "  mcp code <consulta>    - Asistencia de código directa"
            echo "  mcp github <búsqueda>  - Buscar en GitHub directamente"
            echo ""
            echo "⚙️ COMANDOS DE SISTEMA:"
            echo "  mcp models   - Ver modelos de Ollama instalados"
            echo "  mcp pull     - Instalar nuevo modelo"
            echo "  mcp install  - Reinstalar/configurar sistema"
            echo "  mcp status   - Ver estado del sistema"
            echo ""
            echo "💡 EJEMPLOS DE USO DIRECTO:"
            echo "  mcp chat '¿Cómo optimizar este código Python?'"
            echo "  mcp code 'Crear una API REST con FastAPI'"
            echo "  mcp github 'machine learning python'"
            echo ""
            echo "Ubicación: ~$MCP_HOME/"
            ;;
    esac
}

# Aliases de compatibilidad
alias mcp-server='mcp start'
alias mcp-models='mcp models'
alias mcp-status='mcp status'

# Aliases directos para uso rápido desde proyectos
alias ai-chat='mcp chat'
alias ai-code='mcp code'
alias ai-github='mcp github'

# Función para análisis rápido de archivos
analyze() {
    if [ -f "$1" ]; then
        echo "🔍 Analizando archivo: $1"
        mcp code "Analiza este código: $(cat "$1")"
    else
        echo "❌ Archivo no encontrado: $1"
    fi
}

# Función para revisión de código
review() {
    if [ -f "$1" ]; then
        echo "📝 Revisando código: $1"
        mcp code "Revisa este código y sugiere mejoras: $(cat "$1")"
    else
        echo "❌ Archivo no encontrado: $1"
    fi
}

# ======================================
# OLLAMA MCP SERVER - CONFIGURACIÓN ACTUALIZADA
# ======================================

# Función principal MCP (reemplaza configuración antigua)
mcp() {
    case "$1" in
        start|server)
            echo "🚀 Iniciando Ollama MCP Server..."
            cd ~$MCP_HOME && .venv/bin/python3 ollama_mcp_server.py
            ;;
        install|setup)
            echo "📦 Ejecutando instalación/configuración..."
            cd ~$MCP_HOME && python install.py
            ;;
        models)
            echo "🤖 Modelos de Ollama instalados:"
            ollama list
            ;;
        pull)
            if [ -z "$2" ]; then
                echo "Uso: mcp pull <modelo>"
                echo "Ejemplos:"
                echo "  mcp pull deepseek-coder:6.7b"
                echo "  mcp pull qwen2.5-coder:7b"
                echo "  mcp pull llama3.2:3b"
            else
                echo "📥 Instalando modelo: $2"
                ollama pull "$2"
            fi
            ;;
        status)
            echo "📊 Estado del sistema:"
            echo "Ollama: $(ollama list | wc -l) modelos instalados"
            echo "MCP Server: ~$MCP_HOME/"
            echo "Config: $([ -f ~$MCP_HOME/.env ] && echo '✅ Configurado' || echo '❌ Falta .env')"
            ;;
        # Comandos directos de agente (sin servidor interactivo)
        chat)
            shift
            echo "💬 Chat con Ollama..."
            ~$MCP_HOME/.venv/bin/python3 ~$MCP_HOME/mcp_direct.py chat "$@"
            ;;
        code)
            shift
            echo "💻 Asistencia de código..."
            ~$MCP_HOME/.venv/bin/python3 ~$MCP_HOME/mcp_direct.py code "$@"
            ;;
        github)
            shift
            echo "📁 Consultando GitHub..."
            ~$MCP_HOME/.venv/bin/python3 ~$MCP_HOME/mcp_direct.py github_search "$@"
            ;;
        help|*)
            echo "🤖 Ollama MCP Server - Sistema integrado de IA"
            echo ""
            echo "📊 COMANDOS INTERACTIVOS:"
            echo "  mcp start    - Iniciar servidor MCP interactivo"
            echo ""
            echo "🚀 COMANDOS DIRECTOS (desde cualquier proyecto):"
            echo "  mcp chat <mensaje>     - Chat directo con Ollama"
            echo "  mcp code <consulta>    - Asistencia de código directa"
            echo "  mcp github <búsqueda>  - Buscar en GitHub directamente"
            echo ""
            echo "⚙️ COMANDOS DE SISTEMA:"
            echo "  mcp models   - Ver modelos de Ollama instalados"
            echo "  mcp pull     - Instalar nuevo modelo"
            echo "  mcp install  - Reinstalar/configurar sistema"
            echo "  mcp status   - Ver estado del sistema"
            echo ""
            echo "💡 EJEMPLOS DE USO DIRECTO:"
            echo "  mcp chat '¿Cómo optimizar este código Python?'"
            echo "  mcp code 'Crear una API REST con FastAPI'"
            echo "  mcp github 'machine learning python'"
            echo ""
            echo "Ubicación: ~$MCP_HOME/"
            ;;
    esac
}

# Aliases de compatibilidad
alias mcp-server='mcp start'
alias mcp-models='mcp models'
alias mcp-status='mcp status'

# Aliases directos para uso rápido desde proyectos
alias ai-chat='mcp chat'
alias ai-code='mcp code'
alias ai-github='mcp github'

# Función para análisis rápido de archivos
analyze() {
    if [ -f "$1" ]; then
        echo "🔍 Analizando archivo: $1"
        mcp code "Analiza este código: $(cat "$1")"
    else
        echo "❌ Archivo no encontrado: $1"
    fi
}

# Función para revisión de código
review() {
    if [ -f "$1" ]; then
        echo "📝 Revisando código: $1"
        mcp code "Revisa este código y sugiere mejoras: $(cat "$1")"
    else
        echo "❌ Archivo no encontrado: $1"
    fi
}
